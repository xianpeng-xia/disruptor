

## Disruptor性能好的原因

- 数据结构层面：使用环形结构，数组，内存预加载
- 使用单线程写方式，内存屏障
- 消除伪共享（填充缓存行）
- 序号栅栏和序号配合使用来消除锁和CAS

### 1、数据结构-内存预加载机制

- RingBuffer 使用数组Object[] entries作为存储结构，环形循环使用

```
    private final Object[] entries;
```

- event对象预加载 

```
    private void fill(EventFactory<E> eventFactory)
    {
        for (int i = 0; i < bufferSize; i++)
        {
            entries[BUFFER_PAD + i] = eventFactory.newInstance();
        }
    }
```

### 2、内核-单线程写

- 单线程写，做到无锁（Redis,Netty）
- 内存屏障

```
java : valotile变量和happens before语义

linux: smp_wmd()/skp_rmb()
```

- 3、消除伪共享

- 3.1缓存行概念
```
缓存系统中是以缓存行（cache line）为单位存储的

缓存行是2的整数幂个连续字节，一般为32-256个字节

最常见的缓存行大小是64字节

```
- 3.2伪共享概念
```
当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会影响彼此的性能
```

- 3.3伪共享消除
```
Sequence可以看做是一个AtomicLong用于标识进度

class LhsPadding
{
    protected long p1, p2, p3, p4, p5, p6, p7;
}

class Value extends LhsPadding
{
    protected volatile long value;
}

class RhsPadding extends Value
{
    protected long p9, p10, p11, p12, p13, p14, p15;
}

```

### 4、算法优化-序号栅栏机制

- 在生产者进行投递Event的时候总是使用 long sequence = RingBuffer.next();
- 使用SequenceBarrier和序号Sequence搭配使用协调和管理消费者和生产者的工作节奏，避免了锁和CAS的使用
- 每个消费者和生产者持有自己的序号，规则如下，以避免生产者速度过快，将还未来得及消费的消息覆盖
```
消费者序号数值必须小于生产者序号数值

消费者序号数值必须小于其前置（依赖关系）消费者的序号数值

生产者序号数值不能大于消费者中最小的序号数值

```
```
  public long next(int n)
    {
        if (n < 1)
        {
            throw new IllegalArgumentException("n must be > 0");
        }

        long nextValue = this.nextValue;

        long nextSequence = nextValue + n;
        long wrapPoint = nextSequence - bufferSize;
        long cachedGatingSequence = this.cachedValue;

        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)
        {
            cursor.setVolatile(nextValue);  // StoreLoad fence

            long minSequence;
            while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))
            {
                LockSupport.parkNanos(1L); // TODO: Use waitStrategy to spin?
            }

            this.cachedValue = minSequence;
        }

        this.nextValue = nextSequence;

        return nextSequence;
    }
```

### 5、WaitStrategy等待策略深度分析
- waitFor()在ProcessingSequenceBarrier使用
```
    public long waitFor(final long sequence)
        throws AlertException, InterruptedException, TimeoutException
    {
        checkAlert();

        long availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);

        if (availableSequence < sequence)
        {
            return availableSequence;
        }

        return sequencer.getHighestPublishedSequence(sequence, availableSequence);
    }

```
- signalAllWhenBlocking()在SingleProducerSequencer的publish中使用
```
    public void publish(long sequence)
    {
        cursor.set(sequence);
        // 使用策略
        waitStrategy.signalAllWhenBlocking();
    }
```

### EventProcessor核心机制分析

- run
```
    public void run()
    {
        if (running.compareAndSet(IDLE, RUNNING))
        {
            sequenceBarrier.clearAlert();

            notifyStart();
            try
            {
                if (running.get() == RUNNING)
                {
                    processEvents();
                }
            }
            finally
            {
                notifyShutdown();
                running.set(IDLE);
            }
        }
        else
        {
            // This is a little bit of guess work.  The running state could of changed to HALTED by
            // this point.  However, Java does not have compareAndExchange which is the only way
            // to get it exactly correct.
            if (running.get() == RUNNING)
            {
                throw new IllegalStateException("Thread is already running");
            }
            else
            {
                earlyExit();
            }
        }
    }
```